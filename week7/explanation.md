# شبیه‌سازی کدهای CRC در کانال باینری نویزی

این ریپازیتوری مربوط به تمرین درس **شبکه‌های مخابراتی / کدینگ کانال** است.  
در این پروژه عملکرد چند مدل CRC با طول‌های مختلف روی فریم‌های باینری در حضور نویز کانال **BSC** شبیه‌سازی شده است و نتایج به صورت عددی و نموداری تحلیل می‌شوند.

کدها در محیط **Jupyter / Google Colab** اجرا شده‌اند و خروجی‌ها (اعداد و نمودارها) به‌صورت آماده در نوت‌بوک قابل مشاهده هستند تا لازم نباشد هر بار شبیه‌سازی دوباره اجرا شود.

---

## 1. هدف پروژه

هدف اصلی این شبیه‌سازی:

- بررسی **توانایی کشف خطا** توسط کدهای CRC با طول‌های مختلف:
  - `CRC-4`
  - `CRC-8`
  - `CRC-16`
- بررسی اثر:
  - **طول فریم**: `32`، `64` و `128` بیت  
  - **احتمال خطای بیت در کانال (p)**: مقادیر `0.001` و `0.01`
- محاسبه و مقایسه برای هر حالت:
  - تعداد فریم‌های **بدون خطا** (`no_error`)
  - تعداد فریم‌های **دارای خطای کشف‌شده** توسط CRC (`detected_errors`)
  - تعداد فریم‌های **دارای خطای کشف‌نشده** (`undetected_errors`)
  - **نرخ خطای کشف‌نشده** (`undetected_rate = undetected_errors / n_frames`)

به زبان ساده:  
می‌خواهیم ببینیم **اگر کانال نویزی باشد، هر مدل CRC چقدر احتمال دارد خطا را اصلاً نفهمد و پیام اشتباه را “قبول” کند.**

---

## 2. توضیح کلی مدل شبیه‌سازی

برای هر ترکیب از پارامترها (نوع CRC، طول فریم، احتمال خطا):

1. **تولید پیام تصادفی**
   - تولید `n_frames = 3000` فریم باینری تصادفی با طول `frame_len` (مثلاً 32 بیت).
2. **رمزگذاری با CRC**
   - محاسبه بیت‌های CRC با استفاده از چندجمله‌ای مشخص (`poly_bits`).
   - الحاق بیت‌های CRC به انتهای پیام → تشکیل **کدواژه**.
3. **عبور از کانال BSC**
   - هر بیت کدواژه با احتمال `p` مستقل از بقیه، برعکس می‌شود (`0 ↔ 1`).
4. **چک کردن CRC در گیرنده**
   - روی بیت‌های دریافتی دوباره تقسیم CRC انجام می‌شود.
   - اگر باقیمانده (remainder) صفر باشد → **CRC می‌گوید خطایی نیست**.
   - اگر باقیمانده غیر صفر باشد → **CRC متوجه خطا شده است**.
5. **ثبت آمار**
   - اگر **هیچ خطایی در کانال رخ نداده** و CRC هم مشکلی گزارش نکند → `no_error`.
   - اگر **خطا رخ داده** و CRC **خطا را کشف کند** → `detected_errors`.
   - اگر **خطا رخ داده** ولی CRC **خطا را کشف نکند** → `undetected_errors`.
   - در نهایت `undetected_rate = undetected_errors / n_frames` محاسبه می‌شود.

---

## 3. ساختار کد پایتون

### 3.1. توابع کمکی

- `bits_from_int(n, length)`  
  عدد صحیح را به لیست بیت با طول ثابت تبدیل می‌کند.

- `int_from_bits(bits)`  
  لیست بیت را دوباره به عدد صحیح تبدیل می‌کند.

- `xor_bits(a, b)`  
  XOR بیت به بیت دو لیست باینری را حساب می‌کند.

### 3.2. هسته‌ی CRC

- `crc_division(data_bits, poly_bits)`  
  تقسیم چندجمله‌ای باینری (تقسیم ماژولوی ۲) را پیاده‌سازی می‌کند و **باقیمانده** (remainder) را برمی‌گرداند. این بخش همان عملیات اصلی CRC است.

- `crc_encode(message_bits, poly_bits)`  
  1. `k = len(poly_bits) - 1` بیت صفر به انتهای پیام اضافه می‌کند.  
  2. تقسیم CRC را انجام می‌دهد و remainder را حساب می‌کند.  
  3. remainder را جایگزین آن صفرهای انتهایی می‌کند → کدواژه‌ی نهایی.

- `crc_check(received_bits, poly_bits)`  
  روی بیت‌های دریافتی تقسیم CRC را انجام می‌دهد. اگر همه‌ی بیت‌های remainder صفر باشند، **CRC می‌گوید پیام سالم است**.

### 3.3. مدل کانال

- `bsc_channel(bits, p)`  
  کانال باینری متقارن (BSC) را شبیه‌سازی می‌کند. برای هر بیت:
  - با احتمال `p` آن بیت را برمی‌گرداند (خطا).
  - با احتمال `1 - p` بیت را دست‌نخورده عبور می‌دهد.

### 3.4. تعریف چندجمله‌ای‌های CRC

در این پروژه به صورت مثال از چندجمله‌ای‌های زیر استفاده شده:

- `CRC-4`: چندجمله‌ای مثل `x^4 + x + 1` → بردار `[1, 0, 0, 1, 1]`
- `CRC-8`: چندجمله‌ای مثال برای ۸ بیت  
- `CRC-16`: یک چندجمله‌ای نمونه ۱۶ بیتی (نه لزوماً استاندارد CCITT)

این چندجمله‌ای‌ها در دیکشنری زیر نگه‌داری شده‌اند:

```python
crc_models = {
    "CRC-4": CRC4,
    "CRC-8": CRC8,
    "CRC-16": CRC16
}
