# شبیه‌سازی کدهای CRC در کانال باینری نویزی

این ریپازیتوری مربوط به تمرین درس **شبکه‌های مخابراتی / کدینگ کانال** است.  
در این پروژه عملکرد چند مدل CRC با طول‌های مختلف روی فریم‌های باینری در حضور نویز کانال **BSC** شبیه‌سازی شده است و نتایج به صورت عددی و نموداری تحلیل می‌شوند.

کدها در محیط **Jupyter / Google Colab** اجرا شده‌اند و خروجی‌ها (اعداد و نمودارها) به‌صورت آماده در نوت‌بوک قابل مشاهده هستند تا لازم نباشد هر بار شبیه‌سازی دوباره اجرا شود.

---

## 1. هدف پروژه

هدف اصلی این شبیه‌سازی:

- بررسی **توانایی کشف خطا** توسط کدهای CRC با طول‌های مختلف:
  - `CRC-4`
  - `CRC-8`
  - `CRC-16`
- بررسی اثر:
  - **طول فریم**: `32`، `64` و `128` بیت  
  - **احتمال خطای بیت در کانال (p)**: مقادیر `0.001` و `0.01`
- محاسبه و مقایسه برای هر حالت:
  - تعداد فریم‌های **بدون خطا** (`no_error`)
  - تعداد فریم‌های **دارای خطای کشف‌شده** توسط CRC (`detected_errors`)
  - تعداد فریم‌های **دارای خطای کشف‌نشده** (`undetected_errors`)
  - **نرخ خطای کشف‌نشده** (`undetected_rate = undetected_errors / n_frames`)

به زبان ساده:  
می‌خواهیم ببینیم **اگر کانال نویزی باشد، هر مدل CRC چقدر احتمال دارد خطا را اصلاً نفهمد و پیام اشتباه را “قبول” کند.**

---

## 2. توضیح کلی مدل شبیه‌سازی

برای هر ترکیب از پارامترها (نوع CRC، طول فریم، احتمال خطا):

1. **تولید پیام تصادفی**
   - تولید `n_frames = 3000` فریم باینری تصادفی با طول `frame_len` (مثلاً 32 بیت).
2. **رمزگذاری با CRC**
   - محاسبه بیت‌های CRC با استفاده از چندجمله‌ای مشخص (`poly_bits`).
   - الحاق بیت‌های CRC به انتهای پیام → تشکیل **کدواژه**.
3. **عبور از کانال BSC**
   - هر بیت کدواژه با احتمال `p` مستقل از بقیه، برعکس می‌شود (`0 ↔ 1`).
4. **چک کردن CRC در گیرنده**
   - روی بیت‌های دریافتی دوباره تقسیم CRC انجام می‌شود.
   - اگر باقیمانده (remainder) صفر باشد → **CRC می‌گوید خطایی نیست**.
   - اگر باقیمانده غیر صفر باشد → **CRC متوجه خطا شده است**.
5. **ثبت آمار**
   - اگر **هیچ خطایی در کانال رخ نداده** و CRC هم مشکلی گزارش نکند → `no_error`.
   - اگر **خطا رخ داده** و CRC **خطا را کشف کند** → `detected_errors`.
   - اگر **خطا رخ داده** ولی CRC **خطا را کشف نکند** → `undetected_errors`.
   - در نهایت `undetected_rate = undetected_errors / n_frames` محاسبه می‌شود.

---

## 3. ساختار کد پایتون

### 3.1. توابع کمکی

- `bits_from_int(n, length)`  
  عدد صحیح را به لیست بیت با طول ثابت تبدیل می‌کند.

- `int_from_bits(bits)`  
  لیست بیت را دوباره به عدد صحیح تبدیل می‌کند.

- `xor_bits(a, b)`  
  XOR بیت به بیت دو لیست باینری را حساب می‌کند.

### 3.2. هسته‌ی CRC

- `crc_division(data_bits, poly_bits)`  
  تقسیم چندجمله‌ای باینری (تقسیم ماژولوی ۲) را پیاده‌سازی می‌کند و **باقیمانده** (remainder) را برمی‌گرداند. این بخش همان عملیات اصلی CRC است.

- `crc_encode(message_bits, poly_bits)`  
  1. `k = len(poly_bits) - 1` بیت صفر به انتهای پیام اضافه می‌کند.  
  2. تقسیم CRC را انجام می‌دهد و remainder را حساب می‌کند.  
  3. remainder را جایگزین آن صفرهای انتهایی می‌کند → کدواژه‌ی نهایی.

- `crc_check(received_bits, poly_bits)`  
  روی بیت‌های دریافتی تقسیم CRC را انجام می‌دهد. اگر همه‌ی بیت‌های remainder صفر باشند، **CRC می‌گوید پیام سالم است**.

### 3.3. مدل کانال

- `bsc_channel(bits, p)`  
  کانال باینری متقارن (BSC) را شبیه‌سازی می‌کند. برای هر بیت:
  - با احتمال `p` آن بیت را برمی‌گرداند (خطا).
  - با احتمال `1 - p` بیت را دست‌نخورده عبور می‌دهد.

### 3.4. تعریف چندجمله‌ای‌های CRC

در این پروژه به صورت مثال از چندجمله‌ای‌های زیر استفاده شده:

- `CRC-4`: چندجمله‌ای مثل `x^4 + x + 1` → بردار `[1, 0, 0, 1, 1]`
- `CRC-8`: چندجمله‌ای مثال برای ۸ بیت  
- `CRC-16`: یک چندجمله‌ای نمونه ۱۶ بیتی (نه لزوماً استاندارد CCITT)

این چندجمله‌ای‌ها در دیکشنری زیر نگه‌داری شده‌اند:


crc_models = {
    "CRC-4": CRC4,
    "CRC-8": CRC8,
    "CRC-16": CRC16
}


###  نمودار ۱ — نرخ خطای کشف‌نشده نسبت به طول فریم برای CRCهای مختلف

در این نمودار، برای احتمال خطای بیت ثابت `p = 0.01`، محور افقی طول فریم (`32, 64, 128`) و محور عمودی نرخ خطای کشف‌نشده است.  
برای هر طول فریم، سه منحنی مربوط به `CRC-4`، `CRC-8` و `CRC-16` رسم شده‌اند.

**نکات قابل مشاهده:**

#### برای CRC-4:

با افزایش طول فریم از ۳۲ به ۱۲۸ بیت، نرخ خطای کشف‌نشده به‌طور محسوس افزایش پیدا می‌کند:

- برای `frame_len = 32` → حدود `0.001`
- برای `frame_len = 64` → حدود `0.004`
- برای `frame_len = 128` → حدود `0.0216`

**نتیجه:**  
`CRC-4` برای فریم‌های بلند و کانال نسبتاً نویزی (`p = 0.01`) دیگر قابل اعتماد نیست.

#### برای CRC-8:

- نرخ خطای کشف‌نشده تقریباً نزدیک صفر است و فقط در بعضی حالت‌ها مقدار خیلی کوچک (مثلاً `0.0003` یا `0.0006`) دارد.
- نسبت به `CRC-4` عملکرد بسیار بهتر و پایدارتر نشان می‌دهد.

#### برای CRC-16:

- در همه‌ی حالت‌های شبیه‌سازی‌شده، نرخ خطای کشف‌نشده صفر بوده است.
- این به این معنی نیست که تئوریکاً صفر است، بلکه در این تعداد آزمایش (`3000` فریم) هیچ خطای کشف‌نشده‌ای رخ نداده است.

**نتیجه:**  
در این محدوده‌ی آزمایش، `CRC-16` از نظر کشف خطا تقریباً بی‌نقص عمل کرده است.

**جمع‌بندی نمودار ۱:**

- هر چه طول CRC بیشتر باشد، احتمال این‌که خطا از دید CRC مخفی بماند کمتر می‌شود.
- برای کاربردهای حساس، استفاده از `CRC-8` و مخصوصاً `CRC-16` برای فریم‌های بلند، بسیار امن‌تر از `CRC-4` است.

---

###  نمودار ۲ — مقایسه تعداد خطای کشف‌شده و کشف‌نشده (`frame = 64, p = 0.01`)

در این نمودار یک نمودار میله‌ای برای سه نوع CRC رسم شده است.

**شرایط ثابت:**

- `frame_len = 64`
- `p = 0.01`

برای هر CRC دو ستون داریم:

- تعداد خطاهای **کشف‌شده** (`detected_errors`)
- تعداد خطاهای **کشف‌نشده** (`undetected_errors`)

**مقادیر تقریبی (با توجه به نتایج شبیه‌سازی):**

- **CRC-4:**
  - `detected ≈ 1454`
  - `undetected ≈ 12`

- **CRC-8:**
  - `detected ≈ 1519`
  - `undetected ≈ 1`

- **CRC-16:**
  - `detected ≈ 1680`
  - `undetected ≈ 0`

**تحلیل:**

- هر سه CRC بخش اعظم خطاها را کشف می‌کنند (ستون‌های `detected` بزرگ هستند).  
- اما:
  - `CRC-4` هنوز تعدادی خطای کشف‌نشده دارد (۱۲ فریم در ۳۰۰۰ فریم).
  - `CRC-8` فقط ۱ خطای کشف‌نشده داشته است.
  - `CRC-16` در این شبیه‌سازی هیچ خطای کشف‌نشده‌ای ثبت نکرده است.

**نتیجه از نمودار ۲:**

اگر سیستم شما حتی تعداد کمی خطای کشف‌نشده را هم تحمل نمی‌کند،  
`CRC-8` و `CRC-16` گزینه‌های بسیار بهتری نسبت به `CRC-4` هستند.  

به‌خصوص `CRC-16` در این آزمایش‌ها عملاً خطای کشف‌نشده نداشته است.

---

###  نمودار ۳ — نرخ خطای کشف‌نشده نسبت به احتمال خطای بیت (`p`)

در این نمودار:

- محور افقی: احتمال خطای بیت `p` (در مقیاس لگاریتمی، مثلاً `0.001` و `0.01`).
- محور عمودی: نرخ خطای کشف‌نشده.

سه منحنی برای:

- `CRC-4`
- `CRC-8`
- `CRC-16`

**مقادیر استفاده‌شده:**

- **CRC-4:**
  - `p = 0.001` → `undetected_rate = 0.0`
  - `p = 0.01` → `undetected_rate ≈ 0.001` (برای طول فریم خاص)

- **CRC-8:**
  - در هر دو مقدار `p`، نرخ خطای کشف‌نشده تقریباً صفر بوده است.

- **CRC-16:**
  - در هر دو مقدار `p`، در این تعداد آزمایش هیچ خطای کشف‌نشده‌ای دیده نشده است.

**تحلیل:**

- وقتی احتمال خطای بیت کم است (`p = 0.001`)، حتی CRCهای ضعیف‌تر مثل `CRC-4` هم ممکن است در شبیه‌سازی خطای کشف‌نشده نشان ندهند (به خاطر تعداد محدود نمونه).
- وقتی `p` را زیاد می‌کنیم (`0.01`)، خطاها بیشتر می‌شوند و شانس رخ دادن الگوهای خطایی که CRC نتواند ببیند هم افزایش می‌یابد:
  - برای `CRC-4` این اثر دیده می‌شود و نرخ خطای کشف‌نشده دیگر صفر نیست.
  - برای `CRC-8` و `CRC-16` با وجود افزایش `p`، هنوز نرخ خطای کشف‌نشده بسیار نزدیک صفر می‌ماند.

**نتیجه از نمودار ۳:**

- هر چه کانال نویزی‌تر باشد (`p` بزرگ‌تر)، نقش طول CRC مهم‌تر می‌شود.
- `CRC-16` در برابر افزایش نویز، مقاومت بسیار بالاتری نسبت به CRCهای کوتاه‌تر دارد.
